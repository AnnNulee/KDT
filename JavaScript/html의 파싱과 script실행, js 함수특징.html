<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h2>My First Web Page</h2>
    <p>My first paragraph.</p>
    <button type="button" onclick="document.write(5 + 6)">
    Try it
    </button>
    
    <p id = "demo"></p>

    <!--기본적으로 자바스크립트는 페이지의 렌더링을 차단. p 테그까지 파싱이 끝난 상태에서 스크립트 실행. -->
    <script>
        document.getElementById("demo").innerHTML = 5 + 6 ; 
        // innerHTML 하면 html 안에 자바스크립트 코드를 넣을 수 있다.

        apple = 0 // 아무것도 안붙이면 var 로 설정된다. var로 굳이 붙이는 이유는 확실히 '변수선언'이라는 것을 알리기 위해서
        let age = 30;
        //let age = 25; // 이렇게 쓰면 안된다. 같은 스코프 내에서 중복 "선언" 불가. :let은 var에 비해 더 안정적이고 예측 가능한 코드 작성을 가능하게 합니다.
        if(true) {
            let age = 20;  // 하지만 지역 스코프 안에서는 재선언이 가능하다. 
            console.log(age); // 출력 : 20
        }
        console.log(age); // 출력 : 30

        //일반적으로는 const로 선언한다. 안정성을 위함. 

        // 호이스팅(Hoisting)
            // 호이스팅(Hoisting)은 자바스크립트에서 변수 및 함수 ""선언""을 
            // 실제 코드 실행 위치와 관계없이 ""해당 스코프의 최상단""으로 끌어올리는 동작을 나타냅니다.

            // 선언 : 이런 변수, 함수가 '있다'는 존재의 인정. undefined, 변수는 있는데 값이 할당되지 않음
            // 초기화 : 변수, 함수에 값이 할당됨. defined 

        //함수 
            sayHello(); // "Hello, World!" 
            //다만 함수일때는 "실행"개념이기 때문에 아래 펑션을 찾아 실행을 시킨다. 
            function sayHello() {
                console.log("Hello, World! 함수");
            }

        // 함수를 변수처럼 사용 가능.
        const sayHello2 =  function() {
            console.log("Hello, World! 함수를 변수처럼");
            }

        const greet = sayHello2;
        greet(); // Hello, Wolrd! 출력 // () 괄호를 붙여야 함수가 '실행'된다.
        
        // 함수를 변수처럼 사용 가능하다보니 다른 함수의 매개변수전달이 가능해진다. 인수(argument)로 전달 가능
        // 함수를 객체의 속성으로 저장하고 호출도 가능
            const person = {
                name : "alice",
                sayHello : function(){
                    console.log("Hello, World! 객체의 속성으로 저장 가능 ");
                }
            }
        
            //>> 함수를 변수처럼 다루면서 동적인 프로그래밍이 가능. 다양한 방식으로 조합하여 강력한 

        //symbol
            //const uniqueSymbol = symbol('description');
            //const newSymbol = symbol('description');
            //console.log(uniqueSymbol == newSymbol) // false. 둘을 다른값으로 인식하게 함

            //const uniqueSymbol2 = symbol.for('description2');
            //const newSymbol2 = symbol.for('description2');
            //console.log(uniqueSymbol2 == newSymbol2) 


    //연산자
            
        //결합 (+)
            const firstName = "Alice";
            const lastName = "Johnson";
            const fullName = firstName + " " + lastName;
            console.log(fullName); // "Alice Johnson" 출력

            console.log('1'+2) // 12 출력. 둘 다 문자열로 처리됨.  
        
        // 길이 length
            const text = "Ann nulee SHin!"
            console.log(text.length); //5 출력

            console.log(text[0]);
            console.log(text[5]);
            console.log(text[-1]); // reverse indexing은 안됨. 
            console.log(text.substring(0, 5));
            console.log(text.slice(5, 9));

        // +의 위치
        // 전위증가 ++x 
            let x = 5;
            let y = ++x; //이전에 더하기
            console.log(x) //6 출력
            console.log(y) //6 출력

        // 후위증가. a++
            let a = 10;
            let b = a++; // 나중에 더하기
            console.log(a); // 11 출력 (a의 값이 1 증가)
            console.log(b); // 10 출력 (증가되기 전의 a의 값)

        //삼항연산자
            const vAge = 20;
            const canVote = ( vAge >= 18) ? "투표가능" : "투표 불가능"; 
                            // 조건         true시 값  :  false시 값
            console.log(canVote);


        // 연습문제
            // 1
                let fTemp = 122;
                let cTemp = (fTemp - 32) *(5/9);
                console.log(`화씨 ${fTemp}도를 섭씨로 바꾸면 ${cTemp}도 임`);

            //2
                let num1 = 456;
                let num2 = 111;

                console.log(num1-num1%100, num2-num2%100);

            //3
                let anum = 12345;
                // 숫자는 10000의 자리수만 제공
                let anumR = 12345 % 10000 // 2345
                let r1 = (anum - anumR) / 10000 //1

                let anumR2 = anumR % 1000 // 345
                let r2 = (anumR - anumR2) / 1000 //2

                let anumR3 = anumR2 % 100 // 345
                let r3 = (anumR2 - anumR3) / 100 //3

                let anumR4 = anumR3 % 10 // 345
                let r4 = (anumR3 - anumR4) / 10 //4
            
                let anumR5 = anumR4 % 10 // 5
                
                console.log(r1,r2,r3,r4,anumR5 , (r1 + r2 + r3 + r4 + anumR5));


            // 3-1 : 
                let anum2 = 12345;
                let numstr = anum2.toString();

                let n1 = Number(numstr[0]);
                let n2 = Number(numstr[1]);
                let n3 = Number(numstr[2]);
                let n4 = Number(numstr[3]);
                let n5 = Number(numstr[4]);

                console.log(n1 + n2 + n3 + n4 + n5);
                
           
        //switch

            let input = Number(prompt ('숫자입력해주세요(안내프롬프트)', '숫자입력칸'));
            
            switch (input % 2){
                case 0 : 
                    console.log("짝수")
                    break;

                case 1 : 
                    console.log("홀수")
                    break;

                default : 
                    console.log("예외")
                
            }


        //for
        
            for(let i = 0 ; i < 100; i ++) {
                console.log(i)
            }

            // 연습 1

             for(let i = 0; i <5 ; i ++) {
                for ( let j =0; j <= i; j ++ ){
                    console.log("*")   /// Q. 별을 어떻게 연속적으로 박지?
                }
             }

             // 연습 1 - 풀이

             for(let i = 0; i < 5; i ++ ) {
                let star = ""
                for ( let j =0; j <= i; j ++ ){
                    star += "*" // 문자열을 더해주면 옆으로 쭉 나열된다. * + * + * + * + * = *****                
                }
                console.log(star);
             }


             // 별 감소
             for(let i = 5; i > 0; i-- ) {
                let starD = ""
                for ( let j = i; j > 0; j-- ){
                    starD += "*" 
                }
                console.log(starD);
             }


        // 클로저 : 인스턴스랑 비슷함
        // 변수를 잡아두기 위해서 사용함.
            function createCounter() {
                let count = 0; // 지역 변수
            
                function increment() {
                count++;
                console.log(count);
                }
            
                return increment;
            }
            
            const counter1 = createCounter();
             // 함수를 변수에 넣어놓고, '변수'를 실행시키면 클로저가 적용된 함수의 내부변수는 다음에 사용해도 기억해두므로 이내의 지역변수값은 유지가 된다. 
            counter1(); // 출력: 1
            counter1(); // 출력: 2
            

            // 변수이름이 달라지면 다시 첨부터 시작. 클래스와 인스턴스처럼.
            const counter2 = createCounter();
            counter2(); // 출력: 1 (독립된 클로저)
            

            
            // 클로져의 활용 
            function createItemTemplate(category) {
                const items = [];  //배열 생성
              
                return function addItem(item) {   //리턴으로 addItem 함수를 실행, item 변수를 받아 
                  items.push({ category, item });       // 카테고리와 아이템을 푸쉬
                  console.log(items);
                };
            }

            const addFruit = createItemTemplate('Fruit');  // fruit라는 값을 category로 동일한 값으로 잡아내어 item을 추가. 
            addFruit('Apple'); // 출력: [{ category: 'Fruit', item: 'Apple' }]
            addFruit('Banana'); // 출력: [{ category: 'Fruit', item: 'Apple' }, { category: 'Fruit', item: 'Banana' }]

            const addVegetable = createItemTemplate('Vegetable');
            addVegetable('Carrot'); // 출력: [{ category: 'Vegetable', item: 'Carrot' }]


            
        
        /// 짝수만 골라내는 arrow 함수
            const filterEvenNumbers = numbers => numbers.filter(numbers => numbers %2 ==0 );
                                                                // 이 함수의 결과는 true / false.
                                                        // filter를 적용시키면 true만 남고 false는 남지 않는다. (조건에 만족하는것만 남긴다)
                                     // 여기서의 numbers는 파라미터의 이름이 numbers이다. 아래의 배열의 이름으로 지정된 변수와 다른 개념. 
            const numbers = [1, 2, 3, 4, 5, 6];
                    // 여기서는 배열의 이름으로 지정된 변수로 정의됨.
            const evenNumbers = filterEvenNumbers(numbers);

            console.log(evenNumbers); // [2, 4, 6] 출력
            console.log(numbers)
        
            
        // 연습 1
            //함수정의
            const filterLongStrings = str => str.filter( s => s.length >= 5 );
            
            //변수정의 
            const strings = ['apple', 'banana', 'cherry', 'date', 'fig', 'over5iguess'];

            //변수를 함수에 대입 , strings라는 변수를 매개변수(str)으로 받는 filterLongStrings함수 실행
            const longStrings = filterLongStrings(strings);
            console.log(longStrings); // ['banana', 'cherry'] 출력



    </script>
</body>
</html>